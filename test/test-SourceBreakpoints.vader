Include: AwaitTimeout.vader
Include: SubscriptionHelpers.vader

Execute (SourceBreakpoints: Initialize Mock Debug Adapter, Perform Setup):
  " subscribe to all incoming messages
  call g:dapper_middletalker.subscribe('.*', function('StoreMessage'))
  let g:model = dapper#model#Model#new(g:dapper_middletalker)

  " construct SourceBreakpoints, which should (itself) subscribe
  if exists('g:sb') | unlet g:sb | endif
  let g:sb = dapper#model#SourceBreakpoints#new(
      \ g:dapper_middletalker, {'path': g:project_root.'/test/TEST_README.md'})

  " RETURNS:  (v:t_bool)  `v:true` when the given `dapper#model#SourceBreakpoints`
  "     has been fulfilled, e.g. after having received a `SetBreakpointsResponse`.
  function! IsFulfilled(source_bps) abort
    return a:source_bps.status() == 'fulfilled'
  endfunction

  " start mock debug adapter
  let g:start_args = dapper#config#DapperConfig#new(
      \ v:true,
      \ g:dapper_filetypes_to_configs['mock'],
      \ {})
  call DapperStart(g:start_args)
  call AwaitTimeout({ -> ReceivedMessage('InitializedEvent')}, 3000, v:true)

Execute (SourceBreakpoints: Launch Debuggee):
  let g:launch_args = dapper#dap#LaunchRequestArguments#new()
  let g:launch_args['program'] = g:project_root.'/test/TEST_README.md'
  call DapperRequest('launch', 0, g:launch_args)
  call AwaitTimeout({ -> ReceivedMessage('LaunchResponse')}, 4000, v:true)

Execute (SourceBreakpoints: Set Breakpoints):
  " line 2 is empty, so breakpoint should actually be set on line 3
  call g:sb.setBreakpoint({'line': 2, 'condition': '(foo == bar)'})
  call AwaitTimeout({ -> IsFulfilled(g:sb)}, 3000, v:true)
Then:
  let g:bps = g:sb.breakpoints()
  AssertEqual 1, len(g:bps)
  let g:bp = g:bps[0]
  AssertEqual 3, g:bp['line']
  AssertEqual '(foo == bar)', g:bp['condition']

Execute (SourceBreakpoints: Set Additional Breakpoints):
  call g:sb.setBreakpoint({'line': 4})
  call AwaitTimeout({ -> IsFulfilled(g:sb)}, 3000, v:true)
Then:
  let g:bps = g:sb.breakpoints()
  AssertEqual 2, len(g:bps)
  AssertEqual 3, g:bps[0]['line']
  AssertEqual '(foo == bar)', g:bps[0]['condition']
  AssertEqual 4, g:bps[1]['line']

Execute (SourceBreakpoints: Edit Existing Breakpoint):
  call g:sb.setBreakpoint({'line': 3})
  call AwaitTimeout({ -> IsFulfilled(g:sb)}, 3000, v:true)
Then:
  let g:bps = g:sb.breakpoints()
  AssertEqual 2, len(g:bps)
  AssertEqual 3, g:bps[0]['line']
  Assert !has_key(g:bps[0], 'condition') || '(foo == bar)' ==# g:bps[0]['condition']
  AssertEqual 4, g:bps[1]['line']

Execute (SourceBreakpoints: Remove Nonexistent Breakpoint):
  call g:sb.removeBreakpoint(5)
Then:
  let g:bps = g:sb.breakpoints()
  AssertEqual 2, len(g:bps)
  AssertEqual 3, g:bps[0]['line']
  Assert !has_key(g:bps[0], 'condition') || '(foo == bar)' ==# g:bps[0]['condition']
  AssertEqual 4, g:bps[1]['line']

Execute (SourceBreakpoints: Remove Existing Breakpoint):
  call g:sb.removeBreakpoint(3)
  call AwaitTimeout({ -> IsFulfilled(g:sb)}, 3000, v:true)
Then:
  let g:bps = g:sb.breakpoints()
  AssertEqual 1, len(g:bps)
  AssertEqual 4, g:bps[0]['line']

Execute (SourceBreakpoints: Clear All Breakpoints):
  call g:sb.clearBreakpoints()
  call AwaitTimeout({ -> IsFulfilled(g:sb)}, 3000, v:true)
Then:
  let g:bps = g:sb.breakpoints()
  AssertEqual 0, len(g:bps)
