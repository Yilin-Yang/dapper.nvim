Include: MockMiddleTalker.vader

" Test 'hand-off' between DapperBuffer types, using ThreadsBuffer and
" StackTraceBuffer as test types.
Execute (DapperBuffer: Set Up (if this fails, further tests will fail):
  let g:model = dapper#model#Model#New(g:mock_mt)
  let g:tb = dapper#view#ThreadsBuffer#New(g:model, g:mock_mt)

  let g:msg = dapper#dap#Event#New('thread', {'threadId': 123, 'reason': 'started'})
  call g:model.Receive(g:msg)
  call g:tb.Push(g:model.threads(1))

  let g:msg = dapper#dap#Event#New('thread', {'threadId': 789, 'reason': 'started'})
  call g:model.Receive(g:msg)
  call g:tb.Push(g:model.threads(1))

  call g:tb.Open()
Expect:
  <threads>
  thread id: 123	name: unnamed		status: started
  thread id: 789	name: unnamed		status: started
  </threads>

Do (DapperBuffer: can be constructed, and can drill down into a child):
  :call g:tb.Open()\<cr>
  gg\<cr>
Then:
  Assert exists('b:dapper_buffer'), 'Could not find buffer-local StackTraceBuffer'
  call typevim#ensure#IsType(b:dapper_buffer, 'StackTraceBuffer')
  AssertEqual 123, b:dapper_buffer.thread().id()
  let g:child = b:dapper_buffer
  let g:child_bufnr = b:dapper_buffer.bufnr()

Do (DapperBuffer: can return to parent):
  :call g:child.Open()\<cr>
  \<esc>
Then:
  Assert exists('b:dapper_buffer'), 'Could not find buffer-local ThreadsBuffer'
  call typevim#ensure#IsType(b:dapper_buffer, 'ThreadsBuffer')

Do (DapperBuffer: will show a different thing in a different child):
  :call g:tb.Open()\<cr>
  j\<cr>
Then:
  Assert exists('b:dapper_buffer'), 'Could not find buffer-local StackTraceBuffer'
  call typevim#ensure#IsType(b:dapper_buffer, 'StackTraceBuffer')
  AssertEqual 789, b:dapper_buffer.thread().id()
  AssertNotEqual g:child_bufnr, b:dapper_buffer.bufnr()
  let g:second_child = b:dapper_buffer
  let g:second_child_bufnr = g:second_child.bufnr()
  execute "normal \<esc>"

Execute (DapperBuffer: won't open in the same window if the child's open already):
  call g:tb.Open()
  let g:tb_winnr = winnr()
  " if vsplit opens left, then g:child will assume winnr 1
  botright vsplit
  call g:child.Open()
  let g:ch_winnr = winnr()
  wincmd p
  execute "normal gg\<cr>"
Then (and it'll be the same child buffer, in addition to the above):
  " we should have moved to the child's window
  call typevim#ensure#IsType(b:dapper_buffer, 'StackTraceBuffer')
  AssertNotEqual g:tb_winnr, winnr()

  " we didn't do anything that should cause DapperBuffer to reset its children
  AssertEqual g:child_bufnr, b:dapper_buffer.bufnr()

  " climbing back up should return to the old tab
  execute "normal \<esc>"
  call typevim#ensure#IsType(b:dapper_buffer, 'ThreadsBuffer')
  AssertEqual g:tb_winnr, winnr()
  execute g:child.Switch()
  close

Execute (DapperBuffer: will switch to a different tab if child is in that tab):
  " to avoid a 'buffer not modifiable' error from vader
  tabnew

  tabnew
  tabprev
  " open the child in the previous new tab, again to (somehow) avoid exceptions
  " from vader
  call g:child.Open()
  let g:tabnr = tabpagenr()
  tabnext

  call g:tb.Open()
  execute "normal gg\<cr>"
Then:
  call typevim#ensure#IsType(b:dapper_buffer, 'StackTraceBuffer')
  AssertEqual 123, b:dapper_buffer.thread().id()
  AssertEqual g:tabnr, tabpagenr()
  tabnext
  tabclose

Execute (DapperBuffer: should open an existing child even if it's not open anywhere):
  try
    while 1
      call g:child.Switch()
      quit
    endwhile
  catch /ERROR(NotFound)/
  endtry

  try
    while 1
      call g:second_child.Switch()
      quit
    endwhile
  catch /ERROR(NotFound)/
  endtry
  
  let g:winnr = winnr()
  let g:tabnr = tabpagenr()
  call g:tb.Open()
  execute "normal gg\<cr>"
Then:
  call typevim#ensure#IsType(b:dapper_buffer, 'StackTraceBuffer')
  AssertEqual 123, b:dapper_buffer.thread().id()
  AssertEqual g:child_bufnr, b:dapper_buffer.bufnr()

  " should open in the same window, in the same tab
  AssertEqual g:tabnr, tabpagenr()
  AssertEqual g:winnr, winnr()

Execute (DapperBuffer: will reuse an existing child buffer on reset if its still open):
  " close all instances of the second child
  try
    while 1
      call g:second_child.Switch()
      quit
    endwhile
  catch /ERROR(NotFound)/
  endtry

  tabnew
  call g:child.Open()
  let g:child_bufnr = b:dapper_buffer.bufnr()
  tabprev

  let g:msg = dapper#dap#Event#New('thread', {'threadId': 456, 'reason': 'started'})
  call g:model.Receive(g:msg)

  let g:msg = typevim#make#Instance(dapper#dap#ThreadsResponse())
  let g:msg.vim_msg_typename = 'ThreadsResponse'
  let g:msg.success = 1
  let g:new_thread = typevim#make#Instance(dapper#dap#Thread())
  let g:new_thread.id = 456
  let g:new_thread.name = 'foobar'
  call add(g:msg.body.threads, g:new_thread)

  call g:tb.Open()
  call g:model.Receive(g:msg)

  Assert bufexists(g:child.bufnr())
    g:bhilc
Then:
  normal! 2G
  execute "normal \<cr>"
  AssertEqual g:child_bufnr, b:dapper_buffer.bufnr()

  execute "normal \<esc>"
  normal! j
  execute "normal \<cr>"
  AssertNotEqual g:child_bufnr, b:dapper_buffer.bufnr()
  AssertNotEqual g:second_child_bufnr, b:dapper_buffer.bufnr()

  execute "normal \<esc>"
Expect:
  <threads>
  thread id: 456	name: foobar		status: started
  thread id: 123	name: unnamed		status: started
  thread id: 789	name: unnamed		status: started
  </threads>

Execute (DapperBuffer: deletes its managed buffer on CleanUp):
  call MockCleanUp()
  let g:thread_bufnr = g:tb.bufnr()
  let g:child_bufnr = g:child.bufnr()
  Assert bufexists(g:thread_bufnr),
      \ 'ThreadsBuffer stopped existing before cleanup?'
  Assert bufexists(g:child_bufnr),
      \ 'StackTraceBuffer stopped existing before cleanup?'
  call g:tb.CleanUp()
  call g:child.CleanUp()
  " unlet g:tb
  " unlet g:child
Then:
  Assert !bufexists(g:thread_bufnr),
      \ 'ThreadsBuffer did not clean up properly! (Buffer still exists!)'
  Assert !bufexists(g:child_bufnr),
      \ 'StackTraceBuffer did not clean up properly! (Buffer still exists!)'
