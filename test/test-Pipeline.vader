Include: AwaitTimeout.vader

Execute (Pipeline: Setup Model, ThreadsBuffer; Subscribe; Initialize Mock Debug Adapter):
  " subscribe to all incoming messages
  function! StoreMessage(msg) abort
    if !exists('g:messages') | let g:messages = [] | endif
    let g:messages += [a:msg]
  endfunction
  call g:dapper_middletalker.subscribe('.*', function('StoreMessage'))
  let g:model = dapper#model#Model#new(g:dapper_middletalker)

  function! ReceivedMessage(vim_msg_typename) abort
    if !exists('g:messages') | return v:false | endif
    let l:i = 0 | while l:i <# len(g:messages)
      if g:messages[l:i]['vim_msg_typename'] ==# a:vim_msg_typename
        return v:true
      endif
    let l:i += 1 | endwhile
    return v:false
  endfunction

  " setup ThreadsBuffer, which should (itself) subscribe
  if exists('g:tb') | unlet g:tb | endif
  let g:tb = dapper#view#ThreadsBuffer#new(
      \ '[dapper] Threads', g:model, g:dapper_middletalker)

  " start mock debug adapter
  let g:start_args = dapper#config#DapperConfig#new(
      \ v:true,
      \ g:dapper_filetypes_to_configs['mock'],
      \ {})
  call DapperStart(g:start_args)
  call AwaitTimeout({ -> ReceivedMessage('InitializedEvent')}, 3000, v:true)

Execute (Pipeline: Launch Debuggee):
  let g:launch_args = dapper#dap#LaunchRequestArguments#new()
  let g:launch_args['program'] = g:project_root
  call DapperRequest('launch', 0, g:launch_args)
  " call AwaitTimeout({ -> ReceivedMessage('LaunchResponse')}, 4000, v:true)
  sleep 2  " mock debugger doesn't seem to send a LaunchResponse?

Execute (Pipeline: Request Threads):
  call g:model.update()
  call g:tb.open()
  call AwaitTimeout({ -> ReceivedMessage('ThreadsResponse')}, 3000, v:true)
Expect:
  thread	id: 1	name: thread 1	status: (N/A)
  
" Execute (Pipeline: Drill Down):
"   call g:tb.open()
"   normal! gg
"   execute "normal \<cr>"
" Expect:
Execute (Pipeline: Cleanup):
  call g:tb.open()
  normal! ggVGd
