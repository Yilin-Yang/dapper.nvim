Include: AwaitTimeout.vader
Include: StartMockDebugAdapter.vader
Include: SubscriptionHelpers.vader

Execute (Pipeline: Setup Model, ThreadsBuffer; Subscribe; Initialize Mock Debug Adapter):
  " setup ThreadsBuffer, which should (itself) subscribe
  if exists('g:tb') | unlet g:tb | endif
  let g:tb = dapper#view#ThreadsBuffer#New(g:dapper_model, g:dapper_middletalker)

Execute (Pipeline: Launch Debuggee):
  call AwaitTimeout({ -> ReceivedMessage('LaunchResponse')}, 4000, 1)

Execute (Pipeline: Request Threads):
  call g:dapper_model.Update()
  call g:tb.Open()
  call AwaitTimeout({ -> ReceivedMessage('ThreadsResponse')}, 3000, 1)
Expect:
  <threads>
  thread id: 1	name: thread 1		status: entry
  </threads>

Execute (Pipeline: Dig Down into StackTraceBuffer):
  call g:tb.Open()
  normal! gg
  execute "normal \<cr>"
  call AwaitTimeout({ -> ReceivedMessage('StackTraceResponse')}, 4000, 1)
Expect:
  <stacktrace>
  (0)	[NO]	(l:1, c:0)	#(0)
  (1)	[NO]	(l:1, c:0)	Mock(1)
  (2)	[NO]	(l:1, c:0)	Debugger(2)
  (3)	[NO]	(l:1, c:0)	Source(3)
  (4)	[NO]	(l:1, c:0)	File(4)
  </stacktrace>

Execute (Pipeline: Get Stack Frame from Callstack):
  let g:thread = g:dapper_model.thread(1)
  let g:callstack = AwaitPromise(g:thread.stackTrace(), 4000)
  let g:frame_promise = g:callstack.frame(0)
  " echo typevim#object#PrettyPrint(g:frame)
  call AwaitTimeout({ -> g:frame_promise.State() ==# 'fulfilled'}, 4000, 1)
  let g:frame = g:frame_promise.Get()
  AssertEqual '#(0)', g:frame.name()

Execute (Pipeline: Get Local Scope from Stack Frame):
  let g:scope_promise = g:frame.scope('Local')
  call AwaitTimeout({ -> g:scope_promise.State() ==# 'fulfilled'}, 4000, 1)
  let g:scope = g:scope_promise.Get()
  let g:variables_promise = g:scope.variables()
  call AwaitTimeout({ -> g:variables_promise.State() ==# 'fulfilled'}, 4000, 1)
  let g:variables = g:variables_promise.Get()
  let g:local_int = g:variables['local_0_i']
  AssertEqual 'local_0_i', g:local_int.name()
  AssertEqual 'integer', g:local_int.type()
  AssertEqual '123', g:local_int.value()
Then (Check Values in Structured Variable):
  let g:object_top = g:variables['local_0_o']
  AssertEqual 'local_0_o', g:object_top.name()

  " block until children are populated
  let g:child_promise = g:object_top.Children()
  call AwaitTimeout({ -> g:child_promise.State() ==# 'fulfilled'}, 4000, 1)

  let g:var = AwaitPromise(g:object_top.Child('object__i'), 4000)
  AssertEqual 'object__i', g:var.name()
  AssertEqual 'integer',   g:var.type()
  AssertEqual '123',       g:var.value()

  let g:var = AwaitPromise(g:object_top.Child('object__f'), 4000)
  AssertEqual 'object__f', g:var.name()
  AssertEqual 'float',     g:var.type()
  AssertEqual '3.14',      g:var.value()

  let g:var = AwaitPromise(g:object_top.Child('object__s'), 4000)
  AssertEqual 'object__s',   g:var.name()
  AssertEqual 'string',      g:var.type()
  AssertEqual 'hello world', g:var.value()

Execute (Pipeline: Cleanup):
  " call g:tb.CleanUp()
  " unlet g:tb
