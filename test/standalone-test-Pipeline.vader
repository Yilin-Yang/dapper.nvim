Include: AwaitTimeout.vader
Include: StartMockDebugAdapter.vader
Include: SubscriptionHelpers.vader

Execute (Pipeline: Setup Model, ThreadsBuffer; Subscribe; Initialize Mock Debug Adapter):
  " setup ThreadsBuffer, which should (itself) subscribe
  if exists('g:tb') | unlet g:tb | endif
  let g:tb = dapper#view#ThreadsBuffer#New(g:dapper_model, g:dapper_middletalker)

Execute (Pipeline: Launch Debuggee):
  call AwaitTimeout({ -> ReceivedMessage('LaunchResponse')}, 4000, 1)

Execute (Pipeline: Request Threads):
  call g:dapper_model.Update()
  call g:tb.Open()
  call AwaitTimeout({ -> ReceivedMessage('ThreadsResponse')}, 3000, 1)
Expect:
  <threads>
  thread id: 1	name: thread 1		status: (N/A)
  </threads>

Execute (Pipeline: Dig Down into StackTraceBuffer):
  call g:tb.Open()
  normal! gg
  execute "normal \<cr>"
  call AwaitTimeout({ -> ReceivedMessage('StackTraceResponse')}, 4000, 1)
Expect:
  <stacktrace>
  (0)	[NO]	(l:1, c:0)	#(0)
  (1)	[NO]	(l:1, c:0)	Mock(1)
  (2)	[NO]	(l:1, c:0)	Debugger(2)
  (3)	[NO]	(l:1, c:0)	Source(3)
  (4)	[NO]	(l:1, c:0)	File(4)
  </stacktrace>

Execute (Pipeline: Cleanup):
  " call g:tb.CleanUp()
  " unlet g:tb
