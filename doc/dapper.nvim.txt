*dapper.nvim.txt*	neovim frontend for Microsoft's Debug Adapter Protocol.
Yilin Yang <yiliny@umich.edu>                      *dapper.nvim* *dapper.nvim*

==============================================================================
CONTENTS                                                *dapper.nvim-contents*
  1. Introduction..........................................|dapper.nvim-intro|
  2. Configuration........................................|dapper.nvim-config|
  3. Commands...........................................|dapper.nvim-commands|
  4. Dictionaries..........................................|dapper.nvim-dicts|
  5. Functions.........................................|dapper.nvim-functions|

==============================================================================
INTRODUCTION                                               *dapper.nvim-intro*

A neovim frontend for Microsoft's Debug Adapter Protocol, or, a concerted
effort to take the best features of Microsoft's VSCode test editor and crudely
staple them onto neovim.

==============================================================================
CONFIGURATION                                             *dapper.nvim-config*

dapper.nvim may be configured in three ways: by using Google's Glaive plugin;
by setting dapper.nvim's maktaba flags; or by using "legacy" global variables
(i.e. by explicitly setting variables like `g:dapper_dig_down_mapping` in your
vimrc).

The former two are strongly recommended: legacy configuration will work for
"static" configuration, but generally won't be able to change dapper.nvim's
behavior at runtime.

Install Glaive (https://github.com/google/glaive) and use the |:Glaive|
command to configure dapper.nvim's maktaba flags. Alternatively, one can put
the following in their .vimrc:
>
  " retrieve dapper.nvim's plugin handle
  let g:dapper_nvim = maktaba#plugin#Get('dapper.nvim')

  " to set dapper.nvim:dig_down_mapping to '<leader>d'
  call g:dapper_nvim.Flag('dig_down_mapping', '<leader>d')

  " to disable all logging entirely
  call g:dapper_nvim.Flag('min_log_level', 'no_logging')
<

                                                *dapper.nvim:dig_down_mapping*
Keymapping used to "dig down" to a deeper level of a dapper.nvim buffer, e.g.
to go from a "ThreadBuffer" down to the selected "StackTraceBuffer".
Default: dapper#GlobalVarOrDefault('g:dapper_dig_down_mapping', '<cr>') `

                                                *dapper.nvim:climb_up_mapping*
Keymapping used to "climb up" to a higher level of a dapper.nvim buffer, e.g.
to go from a "StackTraceBuffer" up to a "ThreadBuffer".
Default: dapper#GlobalVarOrDefault('g:dapper_climb_up_mapping', '<Esc>') `

                                                  *dapper.nvim:expand_mapping*
Keymapping used to expand the contents of a collapsed scope or "structured"
variable (e.g. a class instance, a struct, a list) in a
|dapper.nvim.VariablesBuffer|.

                                                *dapper.nvim:collapse_mapping*
Keymapping used to collapse the contents of an expanded scope or "structured"
variable in a |dapper.nvim.VariablesBuffer|.
Default: dapper#GlobalVarOrDefault( 'g:dapper_collapse_mapping', '<BS>') `

                                       *dapper.nvim:toggle_breakpoint_mapping*
Keymapping used to toggle breakpoints on the current line. Defaults to "<F9>".
Default: dapper#GlobalVarOrDefault('g:dapper_toggle_breakpoint_mapping',
  '<F9>') `

                                            *dapper.nvim:filetypes_to_configs*
Mapping between a filetype and all debug adapter configurations for that
filetype.
Default: dapper#GlobalVarOrDefault('g:dapper_filetypes_to_configs', {}) `

                                                 *dapper.nvim:log_buffer_name*
The |bufname| of the debug log buffer.
Default: dapper#GlobalVarOrDefault('g:dapper_log_buffer_name', '[dapper] Debug
  Log') `

                                                         *dapper.nvim:logfile*
The output file to which the debug log will be written, if log writing is
enabled.
Default: dapper#GlobalVarOrDefault('g:dapper_logfile',
  $HOME.'/dapper_debug_log.vim.dp') `

                                            *dapper.nvim:log_buffer_writeback*
Whether or not to write the debug log buffer out to a file on exit.
Default: dapper#GlobalVarOrDefault('g:dapper_log_buffer_writeback', 0) `

                                                   *dapper.nvim:min_log_level*
The "lowest" notification level to be written to the debug log buffer.
Messages below this level are ignored, while messages at this level or higher
are printed in their entirety to dapper.nvim's log. This does not affect log
output to maktaba.

May be set to, in order from lowest to highest severity: "debug", "info",
"warn", "error", "severe", "no_logging"

Setting this to "no_logging" disables dapper.nvim's debug logging.

Note that setting this to "low" values, particularly "debug", may incur a
significant performance penalty, as dapper.nvim's debug log output is
extremely verbose. It's recommended to set this no lower than "warn" in
ordinary use.
Default: dapper#GlobalVarOrDefault('g:dapper_min_log_level', 'error') `

                                         *dapper.nvim:max_drilldown_recursion*
When retrieving the contents of a structured variable, dapper.nvim can try to
automatically and recursively retrieve and cache the contents of its children,
so that expanding one of those variables can occur nearly instantly. This
option controls the greatest recursion depth to which dapper.nvim will perform
this inspection. Should be non-negative.

This setting exists to prevent infinite recursion, e.g. if a local variable in
the debuggee process is infinitely self-recursive, dapper.nvim will stop
"drilling down" into its contents after delving this many levels deep. It is
still possible to drill deeper by manually expanding the variable contents in
the |dapper.nvim.VariablesBuffer|.

However, this recursive retrieval blocks vim. If a stack frame has many
(hundreds or more) elements, then inspecting its variables would freeze vim
for up to several minutes. Consequently, this value should never be greater
than zero unless you plan to use it for performance benchmarking.
Default: dapper#GlobalVarOrDefault('g:dapper_max_drilldown_recursion', 0) `

                                       *dapper.nvim:menu_expand_depth_initial*
The initial depth to which scopes and structured variables will be expanded
when viewing scopes and variables accessible in a stack frame. Should be a
non-negative number.

Note that setting this to zero essentially disables on-entry scope expansion
(since any scopes to be expanded will only "expand" to depth 0), overriding
settings like |dapper.nvim:scopes_to_always_expand|.

See |dapper.nvim:menu_expand_depth_on_map| for more details.
Default: dapper#GlobalVarOrDefault('g:dapper_menu_expand_depth_initial', 1) `

                                           *dapper.nvim:preferred_scope_order*
The preferred order in which to display scopes inside of a
|dapper.nvim.VariablesBuffer|. If a scope comes earlier in this list than
another, then it will be shown closer to the top of the buffer.

Matching is done by case-sensitive string comparison. Scopes whose names don't
appear in this list will appear at the end of the buffer sorted in
alphabetical order.
Default: dapper#GlobalVarOrDefault('g:dapper_preferred_scope_order', ['Local',
  'Global']) `

                                        *dapper.nvim:expand_scopes_by_default*
Whether to expand all scopes by default when inspecting a stack frame.
Default: dapper#GlobalVarOrDefault('g:dapper_expand_scopes_by_default', 1,
  v:t_bool) `

                                         *dapper.nvim:scopes_to_always_expand*
Names of scopes that will always be expanded, overriding
|dapper.nvim:expand_scopes_by_default|. Scopes that appear in this list cannot
appear in |dapper.nvim:scopes_to_never_expand|.
Default: dapper#GlobalVarOrDefault('g:dapper_scopes_to_always_expand', []) `

                                          *dapper.nvim:scopes_to_never_expand*
Names of scopes that will never be expanded, overriding
|dapper.nvim:expand_scopes_by_default|. Scopes that appear in this list cannot
appear in |dapper.nvim:scopes_to_always_expand|.
Default: dapper#GlobalVarOrDefault('g:dapper_scopes_to_never_expand',
  ['Global']) `

                                    *dapper.nvim:dont_expand_expensive_scopes*
Debug adapters can report that a particular scope is "expensive to retrieve,"
meaning that it has many variables and that trying to display its contents may
be unacceptably slow. Set this to 1 to avoid expanding these scopes by
default. If set, overrides |dapper.nvim:scopes_to_always_expand| and
|dapper.nvim:expand_scopes_by_default|.
Default: dapper#GlobalVarOrDefault('g:dapper_dont_expand_expensive_scopes', 0,
  v:t_bool) `

                                                *dapper.nvim:plugin[commands]*
Configures whether plugin/commands.vim should be loaded.
Default: 1 `

                                                  *dapper.nvim:plugin[dapper]*
Configures whether plugin/dapper.vim should be loaded.
Default: 1 `

                                                *dapper.nvim:plugin[mappings]*
Configures whether plugin/mappings.vim should be loaded.
Default: 0 `

==============================================================================
COMMANDS                                                *dapper.nvim-commands*

:DapperLog                                                        *:DapperLog*
  Opens dapper.nvim's debug log buffer in the current window.

==============================================================================
DICTIONARIES                                               *dapper.nvim-dicts*

                                                    *dapper.nvim.DapperBuffer*
A Buffer, with additional methods for use in the dapper UI.

In addition to encapsulating a buffer, a DapperBuffer also acts as a parent or
child to other DapperBuffers, allowing DapperBuffers to organize as a tree: UI
updates and information about for "digging down" from one level of information
to another (e.g. from a list of all running threads to a stack trace for a
particular thread), and for "climbing up" from that deeper level back to the
parent level.

DapperBuffer instances will maintain distinct child DapperBuffers for each
object into which the user can drill down. This is so that each child buffer
will remember its previous state (e.g. cursor position), making it easier to
switch between children without "losing one's place."

dapper#view#DapperBuffer#New({message_passer}, [bufparams])
                                                          *DapperBuffer.new()*
  Construct a DapperBuffer.

  {message_passer} is the message-passing interface that DapperBuffer will
  use, which shall have the same interface as |dapper.nvim.MiddleTalker|.

  For [bufparams], see |typevim#Buffer#New()|. The wrapped buffer will be set
  to |nomodifiable| by default, unless explicitly set otherwise.

  Implements |dapper#interface#UpdatePusher()|.

  Throws ERROR(BadValue) if {message_passer} is not a dict.
  Throws ERROR(WrongType) if {message_passer} does not implement a
  |dapper.nvim.MiddleTalker| interface, or if [bufparams] is not a dict.

DapperBuffer.CleanUp()                                *DapperBuffer.CleanUp()*
  Remove this DapperBuffer from the list of its parent's children.

DapperBuffer._Log({kind}, {brief})                       *DapperBuffer._Log()*
  Log a report.

DapperBuffer.Dump()                                      *DapperBuffer.Dump()*
  Dump this buffer's contents and stored state, turning it into a "blank
  slate" comparable to a freshly constructed DapperBuffer.

DapperBuffer.GetRange()                              *DapperBuffer.GetRange()*
  Get the line range of an "entry" inside the buffer itself as a two-element
  list of numbers, which are the first and last line that make up the 'entry',
  inclusive.

  Throws ERROR(NotFound) if the given "entry" could not be found.

DapperBuffer.ConfigureBuffer()                *DapperBuffer.ConfigureBuffer()*
  Set buffer-local settings for a DapperBuffer.

DapperBuffer.ClimbUp([fail_silently])                 *DapperBuffer.ClimbUp()*
  Step up one level to this buffer's parent. If [fail_silently] is false, this
  will throw an ERROR(NotFound) if no parent has been set.

  Calls to `climbUp` will move the cursor to the parent buffer, either by
  switching the focused window or by opening the parent buffer in the current
  window (if it wasn't already open in the same tabpage.)

  [fail_silently] is 0 if omitted.

DapperBuffer._DigDownAndPush({id}, {to_show}) *DapperBuffer._DigDownAndPush()*
  Push the given item {to_show} to all children, and switch to one. Meant to
  be called after determining what {to_show} during a call to
  |dapper#view#DapperBuffer#DigDown()|.

  {id} is some sort of unique identifier for {to_show}, like the
  |dapper#model#StackFrame#id()| of a |dapper.nvim.StackFrame|.

DapperBuffer.Open()                                      *DapperBuffer.Open()*
  Open this buffer, and trigger setup/buffer-local mappings.

DapperBuffer.SetParent({new_parent})                *DapperBuffer.SetParent()*
  Set the parent of this DapperBuffer.

DapperBuffer.GetParent()                            *DapperBuffer.GetParent()*
  Get the parent DapperBuffer of this DapperBuffer.

DapperBuffer.AddChild({new_child})                   *DapperBuffer.AddChild()*
  Mark {new_child} as this buffer's child.

  Throws ERROR(BadValue) if {new_child} is not a dict.
  Throws ERROR(WrongType) if {new_child} does not implement
  |dapper#interface#UpdatePusher(()|).

DapperBuffer.RemoveChild({to_remove})             *DapperBuffer.RemoveChild()*
  Remove a child {to_remove} from this buffer's children. Returns 1 if a child
  was removed, 0 if not.

  Throws ERROR(BadValue) if {to_remove} is not a dict.
  Throws ERROR(WrongType) if {to_remove} does not implement
  |dapper#interface#UpdatePusher(()|).

DapperBuffer.GetChildren()                        *DapperBuffer.GetChildren()*
  Returns a copied list of all of this buffer's children, in no particular
  order.

DapperBuffer._ResetChildren()                  *DapperBuffer._ResetChildren()*
  Destroy children that are not visible. Reset any children that are currently
  showing information, and add them to the list of unused children.

DapperBuffer._GetOpenInTab({buffers}, [tabnr])  *DapperBuffer._GetOpenInTab()*
  Returns the the first DapperBuffer in the given list of {buffers} that is
  open in the tabpage having [tabnr], or the number 0, if none could be found.

  [tabnr] is the current tab if omitted.
  Throws ERROR(WrongType) if {buffers} is not a list of
  |dapper.nvim.DapperBuffer| objects or if [tabnr] is not a number.

                                                   *dapper.nvim.DapperMessage*
A Debug Adapter Protocol message, annotated with a human-readable (and
|dapper.nvim.MiddleTalker|-parsable) typename, and possibly the ID of a
frontend object.

                                                    *dapper.nvim.DapperReport*
A "custom" message type used by dapper.nvim, patterned off of the messages of
the Debug Adapter Protocol. Used for sending information, updates, error
messages, etc. to the frontend.

dapper#dap#DapperReport#New([kind], [brief], [Long], [Other])
                                                          *DapperReport.New()*

  Construct a DapperReport object.

  [Long] and [Other] may both be non-string objects; if they are, then they
  will be pretty-printed to strings on construction.

                                              *dapper.nvim.DebugAdapterConfig*
Basic startup configuration for a debug adapter.

`adapter_id` appears to be the value of `type` in `launch.json`.

dapper#config#DebugAdapterConfig#New({runtime_env}, {exe_filepath},
  {adapter_id})                                     *DebugAdapterConfig.New()*
  Construct a new DebugAdapterConfig object.

  {runtime_env} is the environment in which to run the debug adapter, e.g.
  `"node"`, `"python3"`.

  {exe_filepath} is the filepath of the debug adapter.

  {adapter_id} is equivalent to the `type` attribute of a `launch.json` file.

  Throws ERROR(WrongType) if any of the arguments above are not strings.

                                                     *dapper.nvim.DebugLogger*
A global debug logger. Writes incoming |dapper.nvim.DapperReport|s to a log
buffer and, optionally, a logfile just before vim exits.

Is a wrapper around dapper.nvim's maktaba-provided plugin-wide debug logger.

Public member variables include `buffer`, which is the |TypeVim.Buffer| object
wrapping the DebugLogger's log buffer.

dapper#log#DebugLogger#Interface()                   *DebugLogger.Interface()*
  Returns the interface that DebugLogger implements.

DebugLogger.Get()                                          *DebugLogger.Get()*
  Return a reference to the DebugLogger singleton.

DebugLogger.CleanUp()                                  *DebugLogger.CleanUp()*
  Write the debug log to an output file, if configured to do so.

DebugLogger.Log({report})                                  *DebugLogger.Log()*
  Append a {report} to the dapper-specific debug log.

  Does not log to dapper.nvim's maktaba debugger interface. For that, see
  |DebugLogger.NotifyReport()|.

  Throws ERROR(BadValue) if the given {report} is not a dict.
  Throws ERROR(WrongType) if the given {report} is not a
  |dapper.nvim.DapperReport|.

DebugLogger.ListifyReport({report})              *DebugLogger.ListifyReport()*
  Convert the given {report} instance into a list printable through functions
  like |append()| and return it.

  Throws ERROR(BadValue) if {report} is not a dict.
  Throws ERROR(WrongType) if {report} is not a |dapper.nvim.DapperReport|
  object.

DebugLogger.NotifyReport({kind}, {brief}, [long], [other])
                                                  *DebugLogger.NotifyReport()*
  Make a report. Log it to dapper.nvim's maktaba logger interface, which might
  shout the message at the user. If {kind} is equal to
  |dapper.nvim:min_log_level| or greater, the FULL message will be appended to
  the debug log.

  {kind} is the type of report. These correspond one-to-one with the
  |maktaba.Logger| log levels. This is not case sensitive.

  {brief} is a short (50 characters or less) summary of the report. If this is
  longer than 50 characters, it will be truncated automatically.

  [long] is the verbose content of the message.

  [other] is any other miscellaneous information about the report.

  All optional arguments are pretty-printed into strings, regardless of their
  original type.

  Throws ERROR(BadValue) if {kind} is not a |maktaba.Logger| level.
  Throws ERROR(WrongType) if {kind} or {brief} are not strings.

                                                     *dapper.nvim.DebugSource*

                                                    *dapper.nvim.DebuggeeArgs*
Arguments for starting the debuggee process.

dapper#config#DebuggeeArgs#Interface()              *DebuggeeArgs.Interface()*

DebuggeeArgs.New({request}, {name}, {args}, [initial_bps])
                                                          *DebuggeeArgs.New()*
  Construct a DebuggeeArgs object.

  {request} is either `"launch"` or `"attach"`.

  {name} is a "human-friendly" name for this debug adapter configuration.

  {args} is either a DebugProtocol.LaunchRequestArguments (must be specified
  if {request} is `"launch"`), or a DebugProtocol.AttachRequestArguments (must
  be specified if {request} is `"attach"`).

  [initial_bps] is a struct of InitialBreakpoints to set immediately upon
  construction, or an empty dict (to signify that no initial breakpoints are
  being sent).

  Throws ERROR(BadValue) if {args} or [initial_bps] are not dictionaries.
  Throws ERROR(WrongType) if {request} or {name} aren't strings, if {args}
  does not implement one of the two interfaces as mentioned above, or if
  [initial_bps] is nonempty and not an InitialBreakpoints.

                                                           *dapper.nvim.Event*
A DebugProtocol.Event message.

dapper#dap#Event#New([event] [body])                             *Event.New()*

  Construct a DebugProtocol.Event object.

  [event] is '' if omitted.
  [body] is {} if omitted.
  Throws ERROR(WrongType) if [event] is not a string.

                                              *dapper.nvim.InitialBreakpoints*
Breakpoints to be set immediately after launching a debuggee process.

                                                    *dapper.nvim.MiddleTalker*
The connection between dapper.nvim's VimL frontend and its TypeScript
"middle-end". Provides a subscription-based interface for sending requests to
and receiving messages from the middle-end through neovim's remote plugin
|RPC|, in a manner comparable to a Node.js-style `EventEmitter` object.

Objects can subscribe to messages whose `"vim_msg_typename"` matches a given
regex pattern: MiddleTalker will, on receiving a matching message, call the
subscriber's provided callback function with that matching message. Objects
may also send requests: MiddleTalker will note the sender of the request, and
if it receives a response, will return that request to the sender (and to any
other objects subscribed to messages of that type).

MiddleTalker is a singleton. Because MiddleTalker encapsulates neovim's
program-wide RPC, it does not make sense to have multiple MiddleTalker
instances at a given time.

dapper#MiddleTalker#Interface()                     *MiddleTalker.Interface()*
  Returns the interface that MiddleTalker implements.

dapper#MiddleTalker#get()                                 *MiddleTalker.Get()*
  Get the MiddleTalker singleton, or make one if it doesn't yet exist.

MiddleTalker.__GetID()                                *MiddleTalker.__GetID()*
  Return a request ID number, guaranteed to be distinct from those of all
  existing requests.

MiddleTalker.VimifyMessage({msg})               *MiddleTalker.VimifyMessage()*
  (Re)populate the `vim_msg_typename` and `vim_id` of the given {msg}, based
  on its type and other properties. `vim_id` is set to 0, if not present or
  not a number or string; is converted to a number (by "adding" 0) if a
  string; or left unmodified, if it's just a number.

  Throws ERROR(BadValue) if {msg} is a malformed ProtocolMessage.
  Throws ERROR(WrongType) if {msg} is not a dict, or is not a ProtocolMessage
  at all.

MiddleTalker.Receive({msg})                           *MiddleTalker.Receive()*
  Receive a response or event {msg}, passing it to subscribers.
  Throws ERROR(WrongType) if {msg} is not a dictionary, or if {msg} is not a
  |dapper.nvim.DapperMessage|.

MiddleTalker.Request({command}, {request_args}, {Callback})
                                                      *MiddleTalker.Request()*
  Make a request of the debug adapter. {command} is the `"command"` property
  of a DAP Request; {request_args} is the `"[blank]RequestArguments"` object
  associated with that request type; and {Callback} is the function that the
  MiddleTalker should call after receiving a response to this request.

  Throws ERROR(WrongType) if {command} is not a string, {request_args} is not
  a dict, or if {Callback} is not a |Funcref|.

MiddleTalker.Subscribe({name_pattern}, {Callback})  *MiddleTalker.Subscribe()*
  Register a subscription to messages whose typenames match a {name_pattern},
  a regular expression used to |string-match| against the `"vim_msg_typename"`
  of an incoming message. `"vim_msg_typename"` is a construct of dapper.nvim,
  not of the DAP itself: the middle-end annotates front-going DAP messages
  with a straightforward "human-readable" typename (e.g. a
  LaunchRequestArgument has the `"vim_msg_typename"`:
  `"LaunchRequestArgument"`).

  When {name_pattern} matches against an incoming messages
  `"vim_msg_typename"`, the MiddleTalker will call {Callback}.

  Throws ERROR(WrongType) if {name_pattern} is not a string, or if {Callback}
  is not a |Funcref|.

MiddleTalker.Unsubscribe({name_pattern}, {Callback})
                                                  *MiddleTalker.Unsubscribe()*
  Cancel a subscription, returning 1 when a matching subscription was
  successfully removed, and 0 otherwise.

  {name_pattern} and {Callback} are exactly the same as in
  |MiddleTalker.Subscribe()|; in fact, they should be exactly the same as the
  original arguments (i.e. should compare equal by |expr-==#|) provided when
  the subscription was originally registered.

  Throws ERROR(WrongType) if {name_pattern} is not a string, or if {Callback}
  is not a |Funcref|.

MiddleTalker.NotifyReport({kind}, {brief}, [long], [other])
                                                 *MiddleTalker.NotifyReport()*
  Pass a |dapper.nvim.DapperReport| to the attached |dapper.nvim.DebugLogger|,
  while also sending it to the appropriate subscribers.

                                                           *dapper.nvim.Model*
Encapsulates the state of the debugging process.

Model is primarily responsible for managing the VimL frontend's knowledge of
the debugger's state. It sends `ThreadsRequest`s in response to `ThreadEvent`s
and `StoppedEvent`s, and starts the "request waterfall" described by the Debug
Adapter Protocol specification overview.

Only objects in the `dapper#model` namespace should directly modify the model
state. (`dapper#view` objects can modify the model state indirectly, by
sending DebugProtocol.Request messages.)

dapper#model#Model#Interface()                             *Model.Interface()*
  Returns the interface that Model implements.

Model.Update()                                                *Model.Update()*
  Prompt the Model to update its contents.

Model.thread({tid})                                           *Model.thread()*
  Returns a Thread model object with the requested numerical {tid}.
  Throws ERROR(NotFound) if a matching thread can't be found.
  Throws ERROR(WrongType) if {tid} isn't a number.

Model.threads([include_exited])                              *Model.threads()*
  Returns a dictionary of numerical thread IDs to all stored threads. If
  [include_exited] is true, the returned dictionary will also include stopped
  threads.

  [include_exited] is 0 if omitted.
  Throws ERROR(WrongType) if [include_exited] is not a bool.

Model.capabilities()                                    *Model.capabilities()*
  Returns the capabilities of the running debug adapter.

  Throws ERROR(NotFound) if capabilities have not yet been received.

Model.Receive({msg})                                         *Model.Receive()*
  Update from incoming Debug Adapter Protocol messages.

  Throws ERROR(WrongType) if {msg} is not a dict, or if it is not a
  |dapper.nvim.DapperMessage|.

Model.GetParent()                                          *Model.GetParent()*
  Return the Model's parent UpdatePusher.

Model.SetParent({new_parent})                              *Model.SetParent()*
  Set the parent UpdatePusher of this Model.
  Throws ERROR(BadValue) if {new_parent} is not a dict.
  Throws ERROR(WrongType) if {new_parent} does not implement
  |dapper#interface#UpdatePusher(()|).

Model.AddChild({new_child})                                 *Model.AddChild()*
  Add a child UpdatePusher to this object.
  Throws ERROR(BadValue) if {new_child} is not a dict.
  Throws ERROR(WrongType) if {new_child} does not implement
  |dapper#interface#UpdatePusher(()|).

Model.RemoveChild({to_remove})                           *Model.RemoveChild()*
  Remove the child UpdatePusher {to_remove} from this Model's children. Return
  1 if {to_remove} was found and removed, 0 otherwise.
  Throws ERROR(BadValue) if {to_remove} is not a dict.
  Throws ERROR(WrongType) if {to_remove} does not implement
  |dapper#interface#UpdatePusher(()|).

Model.GetChildren()                                      *Model.GetChildren()*
  Returns a copied list of all this Model's children.

Model.Push()                                                    *Model.Push()*
  Do nothing.

                                                     *dapper.nvim.RequestDoer*
Sends the given {command} with the given {request_args} and resolves with the
results.

dapper#RequestDoer#New({message_passer}, {command}, {request_args})
                                                           *RequestDoer.New()*
  Construct a RequestDoer. {command} is the value of the "command" field of a
  DebugProtocol.Request, while {request_args} is the value of the "arguments"
  field of the same.

  Throws ERROR(WrongType) if {message_passer} doesn't implement a MiddleTalker
  interface, {command} is not a string, {request_args} is not a dict.

                                                        *dapper.nvim.Response*
A DebugProtocol.Response message.

dapper#dap#Response#New([success] [command] [msg_or_body])    *Response.New()*

  Construct a DebugProtocol.Response object.

  [success] is 1 if omitted.
  [command] is '' if omitted.
  Throws ERROR(WrongType) if [success] is not a bool, [command] is not a
  string, or if: [success] is true and [msg_or_body] is not a dict; or
  [success] is false and [msg_or_body] is not a string.

                                                           *dapper.nvim.Scope*
Stores the variables found in a particular DebugProtocol.Scope.

dapper#model#Scope#New({message_passer}, {raw_scope}, {vars_response})
                                                                 *Scope.New()*

  Construct a new Scope object.

  Throws ERROR(BadValue) if {message_passer}, {raw_scope}, and {vars_response}
  aren't all dicts.
  Throws ERROR(WrongType) if {message_passer} does not implement a
  |dapper.nvim.MiddleTalker| interface, or if {raw_scope} is not a
  DebugProtocol.Scope or {vars_response} is not a
  DebugProtocol.VariablesResponse.

Scope.name()                                                    *Scope.name()*
  Return the name of this Scope object, or |v:null| if it could not be found.

Scope.namedVariables()                                *Scope.namedVariables()*
  Return the namedVariables property of this Scope object, or |v:null| if it
  could not be found..

Scope.indexedVariables()                            *Scope.indexedVariables()*
  Return the indexedVariables property of this Scope object, or |v:null| if it
  could not be found.

Scope.expensive()                                          *Scope.expensive()*
  Return the expensive property of this Scope object, or |v:null| if it could
  not be found.

Scope.source()                                                *Scope.source()*
  Return the source property of this Scope object, or |v:null| if it could not
  be found.

Scope.line()                                                    *Scope.line()*
  Return the line property of this Scope object, or |v:null| if it could not
  be found.

Scope.column()                                                *Scope.column()*
  Return the column property of this Scope object, or |v:null| if it could not
  be found.

Scope.endLine()                                              *Scope.endLine()*
  Return the endLine property of this Scope object, or |v:null| if it could
  not be found.

Scope.endColumn()                                          *Scope.endColumn()*
  Return the endColumn property of this Scope object, or |v:null| if it could
  not be found.

Scope.variables()                                          *Scope.variables()*
  Return a |TypeVim.Promise| that resolves to a dict between this scope's
  variable names/indices and their corresponding |dapper.nvim.Variable|
  objects.

                                                      *dapper.nvim.StackFrame*
Stores the scopes for a particular stack frame in a thread's callstack.

dapper#model#StackFrame#New({message_passer}, {stack_frame},
  {scopes_response})                                        *StackFrame.New()*
  Construct a new StackFrame object.

  Throws ERROR(BadValue) if {stack_frame}, {scopes_response}, or
  {message_passer} are not dicts.
  Throws ERROR(WrongType) if {stack_frame} is not a DebugProtocol.StackFrame,
  {scopes_response} is not a ScopesResponse, or if {message_passer} does not
  implement a |dapper.nvim.MiddleTalker| interface.

StackFrame.id()                                              *StackFrame.id()*
  Return a unique identifier for the stack frame.

StackFrame.name()                                          *StackFrame.name()*
  Return the name of the stack frame.

StackFrame.source()                                      *StackFrame.source()*
  Return the DebugProtocol.Source associated with this stack frame, or
  |v:null| if none could be found.

StackFrame.line()                                          *StackFrame.line()*
  Return the line number associated with this stack frame, or |v:null| if none
  could be found.

StackFrame.column()                                      *StackFrame.column()*
  Return the column number associated with this stack frame, or |v:null| if
  none could be found.

StackFrame.endLine()                                    *StackFrame.endLine()*
  Return the final line number associated with this stack frame, or |v:null|
  if none could be found.

StackFrame.endColumn()                                *StackFrame.endColumn()*
  Return the final column number associated with this stack frame, or |v:null|
  if none could be found.

StackFrame.moduleId()                                  *StackFrame.moduleId()*
  Return the name of the module (e.g. Node.js module, external library, etc.)
  associated with this stack frame, or |v:null| if none could be found.

StackFrame.presentationHint()                  *StackFrame.presentationHint()*
  Return a presentation hint for this Stack Frame, or |v:null| if none could
  be found.

StackFrame.scopes()                                      *StackFrame.scopes()*
  Return a list of the names of all scopes accessible from this StackFrame.

StackFrame.scope({name})                                  *StackFrame.scope()*
  Return a |TypeVim.Promise| that resolves to a |dapper.nvim.Scope| object
  representing the DebugProtocol.Scope in this StackFrame with the requested
  {name}.

  Throws ERROR(NotFound) if this StackFrame has no DebugProtocol.Scope with
  {name}.
  Throws ERROR(WrongType) if {name} is not a string.

                                                      *dapper.nvim.StackTrace*
Stores a thread's callstack. Provides an interface to retrieve information
about particular stack frames.

dapper#model#StackTrace#New({message_passer}, {stack_trace_response})
                                                            *StackTrace.New()*
  Construct a new StackTrace object.

  Throws ERROR(BadValue) if {stack_trace_response} or {message_passer} are not
  dicts.
  Throws ERROR(WrongType) if {stack_trace_response} is not a
  StackTraceResponse, or if {message_passer} does not implement a
  |dapper.nvim.MiddleTalker| interface.

StackTrace.totalFrames()                            *StackTrace.totalFrames()*
  Returns the `totalFrames` value provided by the last-received
  StackTraceResponse.

StackTrace.stackFrames()                            *StackTrace.stackFrames()*
  Returns the list of stack frames provided by the last-received
  StackTraceResponse.

StackTrace.frame({index})                                 *StackTrace.frame()*
  Returns a |TypeVim.Promise| that resolves to a |dapper.nvim.StackFrame|
  object constructed from the stack frame at {index} in the callstack.

  Throws ERROR(BadValue) if {index} corresponds to an artificial "label"
  frame.
  Throws ERROR(NotFound) if {index} is out of range.

                                                *dapper.nvim.StackTraceBuffer*
Shows a thread's stack trace. Allows the user to "drill down" into particular
stackframes, or back out into the parent |dapper.nvim.ThreadsBuffer|.

dapper#view#StackTraceBuffer#New({message_passer}, [thread])
                                                      *StackTraceBuffer.New()*
  Construct a StackTraceBuffer from a {message_passer} and, optionally, the
  |dapper.nvim.Thread| object [thread]. If provided, StackTraceBuffer will
  associate with the given [thread] and display its stack trace.

  [thread] is {} if omitted.

  Throws ERROR(BadValue) if {message_passer} or [thread] are not dicts.
  Throws ERROR(WrongType) if {message_passer} does not implement a
  |dapper.nvim.MiddleTalker| interface, or if [thread] is nonempty and is not
  a |dapper.nvim.Thread|.

StackTraceBuffer.thread()                          *StackTraceBuffer.thread()*
  Return the thread object whose callstack this buffer shows.

StackTraceBuffer.Push({thread})                      *StackTraceBuffer.Push()*
  Display the stack trace of the given thread. The buffer will update when the
  StackTraceResponse arrives from the debug adapter, or throw an appropriate
  error message if the request fails entirely.

  Throws ERROR(BadValue) if {thread} is not a dict.
  Throws ERROR(WrongType) if {thread} is not a |dapper.nvim.Thread|.

StackTraceBuffer.ClimbUp()                        *StackTraceBuffer.ClimbUp()*
  Climb back up to a list of all threads.

StackTraceBuffer.DigDown()                        *StackTraceBuffer.DigDown()*
  Open the given stack frame.

                                                       *dapper.nvim.StartArgs*
All arguments supplied to the middle-end. When provided in a call to
|DapperStart()|, starts a debug adapter and a debuggee.

dapper#config#StartArgs#New({adapter_config}, {debuggee_args}, {vscode_attr},
  [locale])                                                  *StartArgs.New()*
  Construct and return new StartArgs object.

  {adapter_config} is a |dapper.nvim.DebugAdapterConfig| object, acting as
  configuration for the debug adapter itself.

  {debuggee_args} is a |dapper.nvim.DebuggeeArgs| object: the debug adapter
  reads this, and uses it to launch or attach to a debugger process.

  {vscode_attr} is a |dapper.nvim.VSCodeAttributes| object, or a basic
  dictionary: it contains other attributes from a `.vscode/launch.json` file
  used specifically by VSCode itself.

  [locale] is a string containing the ISO-639 locale of the neovim frontend,
  e.g. `en_US`.

  Throws ERROR(WrongType) if any of the arguments mentioned above are not of
  the specified types.

                                                          *dapper.nvim.Thread*
Stores information about a running (or stopped) thread: metadata, and the
thread's callstack.

dapper#model#Thread#New({message_passer}, {props})              *Thread.New()*
  Construct a new Thread object. Will automatically request its own stack
  trace on construction.

  {props} is the body of a ThreadEvent (or a similar structure), which can
  contain the following optinal properties:
  "id" or "threadId", which are numbers.
  "name", a string.
  "reason", a string.

  Throws ERROR(WrongType) if the {props} are present and don't have the above
  types, or if {message_passer} isn't a dict.

Thread.id()                                                      *Thread.id()*
  Returns this thread's unique numerical ID.

Thread.name()                                                  *Thread.name()*
  Returns this thread's name.

Thread.status()                                              *Thread.status()*
  Returns the status of this thread.

Thread.stackTrace()                                      *Thread.stackTrace()*
  Returns a Promise that, when resolved, returns the thread's
  |dapper.nvim.StackTrace|.

Thread.Receive({msg})                                       *Thread.Receive()*
  Update this Thread object's stored stack trace from the given {msg}.

  Throws ERROR(BadValue) if {msg} is not a dict.
  Throws ERROR(WrongType) if {msg} is not a ProtocolMessage.

Thread.Update({props})                                       *Thread.Update()*
  Update the properties of this Thread from {props}, which is the body of a
  ThreadEvent. {props} may contain the following optional properties:
  "id" or "threadId"
  "name"
  "reason"

  Calling this function will prompt the Thread to update its cached stack
  trace.

  Throws ERROR(BadValue) if {props} is not a dict.
  Throws ERROR(WrongType) if {props} contains the properties above, but with
  the wrong types.

                                                   *dapper.nvim.ThreadsBuffer*
Shows active threads in the debuggee; 'digs down' into callstacks.

dapper#view#ThreadsBuffer#New({model} {message_passer})  *ThreadsBuffer.New()*
  Construct a ThreadsBuffer using the given {model} (see |dapper.nvim.Model|)
  and {message_passer} (see |dapper.nvim.MiddleTalker|).

  Throws ERROR(BadValue) if {model} or {message_passer} aren't dicts.
  Throws ERROR(WrongType) if {model} or {message_passer} don't implement a
  |dapper.nvim.Model| or |dapper.nvim.MiddleTalker| interface, respectively.

ThreadsBuffer.Push({threads}, [to_highlight])           *ThreadsBuffer.Push()*
  Show the given list of {threads}. If given a |dapper.nvim.Thread|
  [to_highlight], show that at the top of the buffer.

  Throws ERROR(BadValue) if [to_highlight] is provided and is not a dict.
  Throws ERROR(WrongType) if {threads} is not a dict, or if [to_highlight] is
  provided and is not a |dapper.nvim.Thread|.

                                                *dapper.nvim.VSCodeAttributes*
Settings from a `launch.json` that normally control VSCode-specific behavior,
e.g.  `"preLaunchTask"`, `"postLaunchTask"`, `"internalConsoleOptions"` and
`"debugServer"`.

dapper#config#VSCodeAttributes#New([prelaunch] [postlaunch] [console_opt]
  [debugserver])                                      *VSCodeAttributes.New()*
  Construct and return a VSCodeAttributes object.

  [prelaunch] is a "preLaunchTask"; [postlaunch] is a "postLaunchTask";
  [console_opt] are "internalConsoleOptions"; and [debug_server] is a
  [debugServer] port number.

                                                        *dapper.nvim.Variable*
Represent the contents of a variable.

Variable.name()                                              *Variable.name()*
  Return the name of this variable, or |v:null| if it could not be found.

Variable.value()                                            *Variable.value()*
  Return the value of this variable, as a single string, or |v:null| if it
  could not be found.

Variable.type()                                              *Variable.type()*
  Return the type of this variable, or |v:null| if it could not be found.

Variable.presentationHint()                      *Variable.presentationHint()*
  Return a hint as to how this variable should be presented in the UI, or
  |v:null| if it could not be found.

Variable.evaluateName()                              *Variable.evaluateName()*
  Return an expression representing this Variable that is usable in a
  DebugProtocol.EvaluateRequest, or |v:null| if it could not be found.

Variable.variablesReference()                  *Variable.variablesReference()*
  Return the "variablesReference" identifier of this variable, or |v:null| if
  it could not be found. A nonzero return value indicates that this is a
  "structured" Variable with child variables, and that the return value is
  usable in a VariablesRequest.

Variable.namedVariables()                          *Variable.namedVariables()*
  Return the number of named child variables held by this variable, if it is a
  "structured" variable, or |v:null| if it could not be found.

Variable.indexedVariables()                      *Variable.indexedVariables()*
  Return the number of indexed child variables held by this variable, if it is
  a "structured" variable, or |v:null| if it could not be found.

Variable.HasChildren()                                *Variable.HasChildren()*
  Return true if this is a "structured" Variable with children, and false
  otherwise.

Variable.ChildNames()                                  *Variable.ChildNames()*
  Return a |TypeVim.Promise| that resolves with a list of the names of all
  named variable children of this variable, if any.

Variable.Children()                                      *Variable.Children()*
  Return a |TypeVim.Promise| that resolves to a dict between names/indices of
  variables, and the child variables themselves.

Variable.Child({name_or_idx})                               *Variable.Child()*
  Return a |TypeVim.Promise| that resolves to the child Variable having the
  given {name_or_idx}.

  Throws ERROR(NotFound) if no child variable with the given {name_or_idx}
  could be found.
  Throws ERROR(WrongType) if {name_or_idx} is not a string.

                                                  *dapper.nvim.VariableLookup*
Helper class used to asynchronously retrieve a |dapper.nvim.Scope| or a
particular |dapper.nvim.Variable| from within a |dapper.nvim.StackFrame|; in
the latter case, the variable might be nested deeply within other structured
variables.

Meant mainly for use with |dapper.nvim.VariablesBuffer|. Made necessary by the
VariablesRequest "drill-down" procedure needed to retrieve children of a
structured variable.

dapper#model#VariableLookup#Interface()           *VariableLookup.Interface()*
  Returns the interface that VariableLookup implements.

dapper#model#VariableLookup#New({message_passer}, {stack_frame})
                                                        *VariableLookup.New()*
  Construct a VariableLookup object, used for accessing the Model
  representations of some item represented in {stack_frame}.

  {stack_frame} is a |dapper.nvim.StackFrame|. {message_passer} is an object
  that implements the |dapper.nvim.MiddleTalker| interface.

  Throws ERROR(BadValue) if {stack_frame} or {message_passer} are not dicts.
  Throws ERROR(WrongType) if {stack_frame} is not a |dapper.nvim.StackFrame|,
  or if {message_passer} does not implement the MiddleTalker interface.

VariableLookup.VariableFromPath({lookup_path})
                                           *VariableLookup.VariableFromPath()*
  Return a Promise that resolves to a |dapper.nvim.Variable|, or a
  |dapper.nvim.Scope|, corresponding to the given {lookup_path}, from the
  wrapped |dapper.nvim.StackFrame|.

  The {lookup_path} is hierarchical and is analogous to a filepath, with the
  very first element being the name of a scope, the next element being the
  name of a variable within that scope, the next being a member variable in
  the preceding variable, and so on. The last element in the {lookup_path} is
  the Scope/Variable to be returned.

  If {lookup_path} is empty, the returned Promise resolves to a dict between
  all reachable scope names and their corresponding |dapper.nvim.Scope|
  objects.

  If the requested variable could not be found, the returned Promise will
  reject with the text of an ERROR(NotFound) exception.

  Throws ERROR(NotFound) if the given scope could not be found.
  Throws ERROR(WrongType) if {lookup_path} is not a list of strings.

                                                 *dapper.nvim.VariablesBuffer*
Shows variables accessible from the current stack frame, organized by their
parent scope.

dapper#view#VariablesBuffer#New({message_passer}, [stack_frame])
                                                       *VariablesBuffer.New()*
  Construct a VariablesBuffer from a {message_passer} and, optionally, the
  |dapper.nvim.StackFrame| object that the VariablesBuffer should show.

  [stack_frame] is {} if omitted.

  Throws ERROR(BadValue) if {message_passer} or [stack_frame] are not dicts.
  Throws ERROR(WrongType) if {message_passer} does not implement a
  |dapper.nvim.MiddleTalker| interface, or if [stack_frame] is nonempty and is
  not a |dapper.nvim.StackFrame|.

VariablesBuffer.stackFrame()                    *VariablesBuffer.stackFrame()*
  Return the stack frame object whose scopes and variables this buffer shows.

VariablesBuffer.Push({stack_frame})                   *VariablesBuffer.Push()*
  Display the scopes (and the variables) accessible from the given
  {stack_frame}. The buffer will update when the given
  |dapper.nvim.StackFrame| receives DebugProtocol.VariablesResponse updates
  from the debug adapter, or throw an appropriate error message if the request
  fails entirely.

  Throws ERROR(BadValue) if {stack_frame} is not a dict.
  Throws ERROR(WrongType) if {stack_frame} is not a |dapper.nvim.StackFrame|.

VariablesBuffer.Dump()                                *VariablesBuffer.Dump()*
  Dump the contents and stored state of this VariablesBuffer.

VariablesBuffer.GetRange({lookup_path_of_var})    *VariablesBuffer.GetRange()*
  See |dapper#view#VariablesPrinter#GetRange()|.

VariablesBuffer.ExpandSelected()            *VariablesBuffer.ExpandSelected()*
  Expand (or merely update) the currently selected |dapper.nvim.Scope| or
  |dapper.nvim.Variable| inside the current buffer.

VariablesBuffer.CollapseSelected()        *VariablesBuffer.CollapseSelected()*
  Collapse the currently selected |dapper.nvim.Scope| or
  |dapper.nvim.Variable| inside the current buffer.

  If the currently selected |dapper.nvim.Variable| is an unstructured
  variable, or if it's a structured variable that's already been collapsed,
  instead collapse its parent |dapper.nvim.Scope| or |dapper.nvim.Variable|.

VariablesBuffer.PrintScopes({scopes}, [rec_depth])
                                               *VariablesBuffer.PrintScopes()*
  Print each scope in {scopes} as a collapsed item at the top of the managed
  buffer, after the leading `<variables>` tag, making asynchronous requests to
  expand each one.

  {scopes} is a list of strings, with each string being the name of a
  |dapper.nvim.Scope| in the stack frame being shown.

  [rec_depth] is 3 if omitted.
  Throws ERROR(WrongType) if {scopes} is a not list of strings, or [rec_depth]
  is not a number.

                                                *dapper.nvim.VariablesPrinter*
An object for printing the contents of scopes and variables.

Provides functions for printing, collapsing, and expanding scoped blocks of
text: in this case, actual variable scopes and the variables therein. Meant
manipulate in this case, actual variable scopes and the variables therein.
Also provides functions for checking to see which items the user is trying to
modify.

Meant to be a "single-use" member variable in a VariablesBuffer, in that it
should be replaced with a new VariablesPrinter once the VariablesBuffer has
been pushed a new StackFrame.

Most member functions take in a `{lookup_path_of_var}` See
|dapper.nvim.VariableLookup| for information on how this argument should be
structured.

dapper#view#VariablesPrinter#New({message_passer}, {buffer}, {var_lookup})
                                                      *VariablesPrinter.New()*
  Construct a VariablesPrinter.

  {message_passer} is an object satisfying the |dapper.nvim.MiddleTalker|
  interface. {buffer} is the |TypeVim.Buffer| object that this object will
  manipulate. {var_lookup} is a |dapper.nvim.VariableLookup| object.

  Throws ERROR(BadValue) if {message_passer}, {buffer}, or {var_lookup} are
  not dicts.
  Throws ERROR(WrongType) if {message_passer} does not implement a
  |dapper.nvim.MiddleTalker| interface, {buffer} is not a |TypeVim.Buffer|, or
  {var_lookup} does not implement a |dapper.nvim.VariableLookup| interface.

VariablesPrinter.GetRange({lookup_path_of_var})  *VariablesPrinter.GetRange()*
  Get the range of lines in the managed buffer in which the given variable is
  printed. Takes in a {lookup_path_of_var}.

  Returns a two-element list: the first and last line containing the requested
  variable, inclusive.

  Throws ERROR(BadValue) if {lookup_path_of_var} contains values that aren't
  strings, or is empty.
  Throws ERROR(NotFound) if no matching variable could be found. This may also
  occur if the requested variable is hidden in a collapsed block.
  Throws ERROR(WrongType) if {lookup_path_of_var} is not a list.

VariablesPrinter.VarFromCursor({curpos}, [return_as_lookup_path])
                                            *VariablesPrinter.VarFromCursor()*
  Given a cursor position in the managed buffer (as returned by `getpos('.')`
  or by |getcurpos()|), return the variable or scope in which that cursor
  position lay.

  If [return_as_lookup_path] is 1, the requested scope or variable will be
  returned as a lookup path. If it's 0, this function will return a
  |dapper.nvim.Scope| or |dapper.nvim.Variable|, as appropriate.

  [return_as_lookup_path] is 0 if omitted.
  Throws ERROR(BadValue) if the given {curpos} is not a four- or five-element
  list whose second element is a number.
  Throws ERROR(NotFound) if the given {curpos} does not correspond to any
  scope or variable in the managed buffer.
  Throws ERROR(WrongType) if the given {curpos} is not a list, or if
  [return_as_lookup_path] is not a bool.

VariablesPrinter.ExpandEntry({var_or_scope}, {lookup_path_of_var},
  [rec_depth])                                *VariablesPrinter.ExpandEntry()*
  Expand the given scope or variable in the managed buffer. If the expansion
  was successful, return 1. If it was not (e.g. the variable was already
  expanded, or the variable is not a "structured" variable that can be
  expanded) return 0.

  If the given {var_or_scope} is an unstructured variable, simply update that
  variable's value in the managed buffer. [rec_depth] will have no effect.

  [rec_depth] is the number of "levels deep" to which {var_or_scope} and its
  children should be printed. If equal to 1, only {var_or_scope} will be
  printed in a "collapsed" state. If equal to 2, {var_or_scope} will be
  printed, and its immediate children will be printed in a "collapsed" state,
  and so on.

  [rec_depth] is 3 if omitted.
  Throws ERROR(BadValue) if {lookup_path_of_var} contains values that aren't
  strings, or if [rec_depth] is not a positive number.
  Throws ERROR(NotFound) if {lookup_path_of_var} corresponds to no known scope
  or variable.
  Throws ERROR(WrongType) if the given {lookup_path_of_var} is not a list.

VariablesPrinter.CollapseEntry({lookup_path_of_var})
                                            *VariablesPrinter.CollapseEntry()*
  Collapse the given scope or variable in the managed buffer. If the collapse
  was successful, return 1. If it was not (e.g. the variable was already
  collapsed, or the variable is not a "structured" variable that can be
  collapsed) return 0.

  Throws ERROR(BadValue) if {lookup_path_of_var} contains values that aren't
  strings.
  Throws ERROR(NotFound) if {lookup_path_of_var} corresponds to no known scope
  or variable.
  Throws ERROR(WrongType) if the given {lookup_path_of_var} is not a list.

VariablesPrinter.UpdateValue({lookup_path}, {new_props})
                                              *VariablesPrinter.UpdateValue()*
  Update the value of a |dapper.nvim.Variable| in the managed buffer.

  {new_props} is a dictionary that may contain:
  value: A string, the new value of the variable.
  type?: An optional string, the variable's new type.
  namedVariables?: An optional number, the number of named child variables.
  indexedVariables?: An optional number, the number of indexed child
    variables.

  {new_props} may also be a |dapper.nvim.Variable|, in which case it will be
  converted into a dictionary matching the structure above.

  Properties with keys not matching the above are silently ignored. If
  {lookup_path} corresponds to a |dapper.nvim.Scope|, the `value` key has no
  effect. Unspecified properties are not modified.

  Throws ERROR(BadValue) if {lookup_path} contains values that aren't strings,
  or if {lookup_path} is empty, or if {new_props} is not a dict.
  Throws ERROR(NotFound) if {lookup_path} corresponds to no known scope or
  variable.
  Throws ERROR(WrongType) if the given {lookup_path} is not a list, or if
  {new_props} does not conform to the interface described above.

VariablesPrinter._LogFailure({update_type}, [more])
                                              *VariablesPrinter._LogFailure()*
  Show/Log information about a failed asynchronous buffer update.

  {update_type} is the type of the failed update (e.g. asynchronous entry
  expansion, update variable value, etc.). [more] is any other relevant
  information, e.g. a |v:exception|, and can be of any type.

  [more] is "" if omitted.
  Throws ERROR(WrongType) if {update_type} is not a string.

==============================================================================
FUNCTIONS                                              *dapper.nvim-functions*

dapper#receive({msg})                                       *dapper#receive()*
  Receive a response or event from the TypeScript middle-end.

dapper#GlobalVarOrDefault({setting_name}, {default}, [type])
                                                 *dapper#GlobalVarOrDefault()*
  Return the value of {setting_name}, a scoped variable (e.g.
  `"g:dapper_foobar"`, including the leading `"g:"`), or {default}, if
  {setting_name} has no value set.

  This function exists so that dapper.nvim may present a familiar, "legacy"
  interface for plugin settings to the end user, should they decide not to use
  glaive.

  [type], if not equal to -1, is the type that the setting represented by
  {setting_name} should possess. If equal to -1, the function will compare the
  setting's type against that of {default}.

  [type] is -1 if omitted.
  Throws ERROR(WrongType) if [type] is -1 and the variable that {setting_name}
  represents does not have the same type as {default}; or if [type] is not -1
  and the setting's type does not match it.
  Throws ERROR(Failure) if {setting_name} is malformed.

dapper#ensure#IsValidLogLevel({level})       *dapper#ensure#IsValidLogLevel()*
  Checks if the given {level} corresponds to a valid maktaba notification
  level (see |maktaba#log#SetNotificationLevel|), or if {level} is the string
  "none". Returns {level} for convenience.

  Throws ERROR(BadValue) if {level} is not a valid notification level, or the
  string "none".
  Throws ERROR(WrongType) if {level} is not a string.

dapper#helpers#LevelToNum(level)                 *dapper#helpers#LevelToNum()*
  Converts the given maktaba notification level (see
  |maktaba#log#SetNotificationLevel|) to a numerical value. "Lower"
  notification levels have lower numerical values than "higher" levels, e.g.
  "debug" corresponds to a lower value than "info", which has a lower value
  than "warn".

  {level} may also be "none", which returns a numerical value larger than all
  "true" notification levels.

  Throws ERROR(BadValue) if {level} is a string but is not a maktaba
  notification level.
  Throws ERROR(WrongType) if {level} is not a string.

dapper#interface#UpdatePusher()              *dapper#interface#UpdatePusher()*
  Return an interface for an "update pusher" object, an object that may exist
  in a tree, which may accept updates from a parent and push updates to
  children.

dapper#model#Variable#New({message_passer}, {variable})
                                                 *dapper#model#Variable#New()*
  Construct a Variable object from a {message_passer} and a {variable}.

  Throws ERROR(BadValue) if {message_passer} or {variable} are not dicts.
  Throws ERROR(WrongType) if {message_passer} does not implement a
  |dapper.nvim.MiddleTalker| interface, or if {variable} is not a
  DebugProtocol.Variable.

dapper#view#StackTraceBuffer#GetRange({index})
                                     *dapper#view#StackTraceBuffer#GetRange()*
  Return the line range of the stack frame with the given index.

  Throws ERROR(BadValue) if given a negative {index}.
  Throws ERROR(NotFound) if the given entry can't be found.
  Throws ERROR(WrongType) if {index} isn't a number.


vim:tw=78:ts=8:ft=help:norl:
